# Fundot 新手指南

本文为一篇 Fundot 编程语言的教程。

## 目录

1. [简介](#简介)
2. ["Hello, World!"](#"hello-world")
3. [基本组成部分](#基本组成部分)
4. [语法规则](#语法规则)
5. [Quote 符号](#Quote-符号)
6. [函数定义](#函数定义)
7. [条件语句](#条件语句)
8. [Equal 函数](#Equal 函数)
9. [数字](#数字)
10. [Atom 函数](#Atom 函数)
11. [向量](#向量)
12. [Block 函数](#Block 函数)

## 简介

Fundot 编程语言是一门受到 Lisp 启发的函数式编程语言，旨在为“代码即数据”的编程提供一个更简洁易读的解决方案。

## "Hello, World!"

为了使读者们更快的熟悉 Fundot 编程语言，我们先编写并运行一个简单的程序来输出 "Hello, World!"：

```Fundot
>>> Print "Hello, World!".
Hello, World!
```

其中 Print 函数的作用是打印作为参数的字符串。我们可以看到，Fundot 的语法与英语非常相似，很符合我们大部分人的直觉，这事实上也反映出 Fundot 的设计哲学：简洁、易读、符合直觉。接下来，让我们来系统地学习一下这门编程语言。

## 基本组成部分

Fundot 程序由三个基本部分组成：

* [原子](#原子)
* [字符串](#字符串)
* [表达式](#表达式)

### 原子

Fundot 语法中最小的组成部分是原子（Atom），任何没有间隔并且首字母不大写的一组字符都是一个原子，一个空的向量（vector）也是一个原子。以下为一些原子的示例：

```Fundot
one-hundred
100
"hello"
Vect.
```

**注意：** 间隔是指空格（whitespace）、制表符（tab）、换行（newline）和类似能使字符分隔的符号

### 字符串

Fundot 和其它编程语言一样，也拥有字符串，但是我们从以上示例可以发现，像 "hello" 这样没有间隔的字符串，本质上与原子无异。但是由于在很多情况下，字符串之间需要有一定间隔，比如：

```Fundot
"Hello, World!"
```

所以需要将字符串单独进行定义：任何被双引号包含并且中间存在间隔的一组字符都是一个字符串。以下为一些字符串的示例：

```Fundot
" Hello, World! "
"My name is Mike."
"He says \"yes\"."
```

在最后一个示例当中，我们可以发现，在内部的两个双引号前方，我们使用了 \ 符号，这是为了避免解释器认为字符串提前结束而加入的转义字符，如果想要在字符串内表达 \，则可以使用 \\\\，代码运行效果如下：

```Fundot
>>> Print "He says \"yes\".".
He says "yes".
>>> Print " \\ \\ ".
 \ \ 
```

### 表达式

表达式（expression）是 Fundot 中最基础也最重要的语法结构，所有函数都通过表达式进行调用。任何首字母大写并且由点结尾的原子序列或者一个单独的原子，都被称之为表达式，表达式的实质其实就是向量（vector）。以下为一些示例:

```Fundot
x
Def x 1.
Num+ 1 1.
Quote x.
If true Print "true".
```

## 语法规则

秉着简洁和自洽的想法，Fundot 的核心语法规则非常简单，可以用一句话进行概括：除了被 Quote 函数所包含的表达式以外，Fundot 将由内而外地执行包括函数参数和表达式成员的所有内容。示例如下：

```Fundot
>>> Def x 1.
>>> Print x.
1
>>> Print Quote x..
x
>>> Def Quote x. 2.
>>> x
2
```

从以上代码中，我们可以体会到 Quote 函数的作用：阻止其中的内容被执行。其中 Def 函数用于定义变量和函数，具体功能将在之后进行详细介绍。更值得注意的是：在我们第一次定义 x 的时候，我们不需要使用 Quote 函数，这是因为 x 在没有被定义之前只是 x 本身，被执行后的返回值也是 x 自己，但是在第一次定义 x 之后，如果想要对 x 重新进行定义，就必须将对 x 使用 Quote 函数。否则，在执行 Def 函数之前，其中的 x 就会被执行，从而变成 1， 而定义也就随之变成了:

```Fundot
Def 1 2.
```

这显然不是在一般情况下我们想要的。

## Quote 符号

鉴于 Quote 函数的重要性和特殊性，Fundot 提供两种符号化的手段来调用 Quote 函数：前缀单引号和后缀单引号。

### 前缀单引号

前缀单引号的作用是使紧随其后的表达式整体被 Quote 函数包含，比如：

```Fundot
'Def x 1.
```

相当于

```Fundot
Quote Def x 1..
```

### 后缀单引号

后缀单引号的作用是使其跟随的表达式内部被 Quote 函数包含， 比如：

```Fundot
Def' x 1.
```

相当于

```Fundot
Def Quote x 1..
```

## 函数定义

在以上讨论当中，我们使用了 Fundot 语言当中的内置函数：Def、Quote、Print。但是很多时候，Fundot 所提供的函数并不能够完全满足我们的需求。这个时候，我们就需要自己定义一个函数。自定义使用 Def 函数：

```Fundot
Def Function [arguments]. <body>.
```

这种表达方式将会在本指南中广泛应用，其中中括号内的为一个序列，尖括号内的为一个表达式，其等同于：

```Fundot
Def Function argument_1 argument_2 ... argument_n. Body [arguments]..
```

自定义函数和自定义变量均使用 Def 函数，事实上，在 Fundot 当中，函数除了具有参数以及使用参数的能力以外，与变量几乎没有区别，比如：

```Fundot
>>> Def x 1.
>>> x
1
>>> Def X. 1.
>>> X.
1
```

由以上代码，我们可以看到，如果一个函数不需要任何的参数，那么它除了表达方式外与一个变量基本完全相同。这也体现了 Fundot 的极简主义，只要是能合并在一起的东西，就不会另起炉灶。下面就让我们定义一个具有参数并且使用参数的函数吧：

```Fundot
>>> Def' Factorial n.
				If' Num= n 1. 1
				else Num* n Factorial Num- n 1.....
>>> Factorial 5.
120
```

我们定义了一个阶乘函数，并且成功地输出了 5 的阶乘：120。其中所涉及到的其它内置函数：Num=、Num*、Num- 和 If，将会在接下来的章节陆续进行讲解，你现在可以简单的把他们看作：相等判断、相乘、相减和条件语句。简而言之，我们所定义的阶乘函数，名称为 Factorial，使用时需要提供一个参数 n。函数体的作用是：如果 n 等于 1，就直接返回 1。不然就返回 n * (n - 1)!，进行递归，一直到 n 等于 1 为止。虽然 Fundot 语言提供循环，但是由于 Fundot 是按照函数式语言进行地设计，但是像这样使用递归的方式来定义和使用函数，更加推荐。以上函数可以用数学语言表达为以下形式：
$$
Factorial(n) =  
\begin{cases} 
	1 & n = 1 \\
	n * Factorial(n - 1) & otherwise
\end{cases}
$$
值得一提的是，Fundot 语言并不依靠缩进等格式进行解释，而是依靠语言和符号。缩进的唯一作用就是使代码变得更加美观。所以说以上函数，也可以写成：

```Fundot
Def' Factorial n. If' Num= n 1. 1 else Num* n Factorial Num- n 1.....
```

这种写法在 Fundot 当中与上面的写法效果完全相同，唯一的区别就是不方便程序员进行阅读。

## 条件语句

### Cond 函数

按理说，条件语句的讲解通常应当放在变量定义之后，函数定义之前，但是由于 Fundot 语言的特殊性，变量和函数的定义方式一样，所以我们优先对 Def 函数进行了说明，现在才回头看条件语句。有需要的读者，可以看完这一部分，再回头浏览一下之前定义的 Factorial 函数。Fundot 语言对此首先提供的函数为 Cond 函数：

```Fundot
Cond <predicate_1> <expression_1>
		<predicate_2> <expression_2>
		... ...
		<predicate_n> <expression_n>
		else <expression_else>.
```

Cond 函数的参数是若干个断言和对应的表达式，作用是对第一个返回值为 true 的断言所对应的表达式进行执行。示例如下：

```Fundot
>>> Cond' false Num+ 1 1. false 1 true Num+ 2 2..
4
```

这个表达式中，第一个返回 true 的断言就是 true，所以就执行了紧随其后的那个表达式，返回了两个 2 的和，也就是 4。我们可以注意到 Cond 的后面有一个后缀单引号，它的作用是将 Cond 的所有参数使用 Quote 函数进行包含（详见 [Quote 符号](#Quote 符号)），否则在 Cond 执行之前，其中所包含的`Num+ 1 1.` 和 `Num+ 2 2.`就会被执行，变成 2 和 4，虽然在这里，不加单引号，也会返回 4，但是我们通常是想要先进行判断，再执行，所以一般情况下，Cond 的后面都会加上一个单引号。

Cond 语句中可以识别一个叫做 else 的关键词，如果 else 之前的条件均不为正确，则执行 else 后方的表达式，但是 else 语句不是必须的，示例如下：

```Fundot
>>> Cond false 0 false 1 false 2 else 3.
3
```

我们也可以看到，因为上述参数当中，没有表达式会被执行，所以我们可以不必在 Cond 后方加入单引号，但是即便我们加入了单引号效果依然相同，所以在 Fundot 当中，如果不好进行判断，那么在 Cond 后面加上后缀单引号总是一个好习惯。

### If 函数

为了迎合广大程序员，以及进一步符合直觉，我们也提供了 If 函数作为条件语句，以上阶乘函数中，我们就进行了使用。其具体用法如下：

```Fundot
If <predicate_1> <expression_1>
else if <predicate_2> <expression_2>
		... ...
else if <predicate_n> <expression_n>
else <expression_else>.
```

我们可以看到，If 函数与 Cond 函数如出一辙，只不过更加繁琐地在第二个一直到倒数第二个断言之前加上了 else if 关键词。所以说，在 Fundot 当中，If 函数的作用是优化只有两种情况时条件语句的易读性，一般使用如下：

```Fundot
If <predicate> <expression>
else <expression_else>.
```

例如：

```Fundot
>>> Def x 1.
>>> If Equal x 0. 0
		else 1.
1
```

这样写，的确会使代码在一定程度上更加直观，但是在需要多个断言的情况下，依然建议使用 Cond 语句。

## Equal 函数

作为 Fundot 的基本函数之一，Equal 函数的作用就是判断其两个参数是否相等：

```Fundot
Equal value_1 value_2.
```

如果两个参数相等，就会返回 true，否则就会返回 false，比如：

```Fundot
>>> Def x 1.
>>> Def y 2.
>>> Equal x y.
false
>>> Def 'x 2.
>>> Equal x y.
true
```

我们在一开始，先定义了变量 x 和 y，分别为 1 和 2，所以对他们使用 Equal 函数的返回结果是 false，但是当我们重新定义 x 为 2 后，再次使用 Equal，返回值就变成了 true。但是值得一提的是，Equal 函数所判断的是，二者执行后的形式，并非通常情况下的相等，比如：

```Fundot
>>> Equal 0 0.
true
>>> Equal 0 0.0.
false
>>> Num= 0 0.0.
true
```

通过以上代码，我们可以发现，0 与 0 在 Equal 函数下确实相等，但是 0 和 0.0 却并不是，这是因为二者虽然在数学中相等，但是在 Fundot 当中却具有不同的形式，对于这种情况，我们需要针对性地使用相等判断，比如对于两个数字，我们通常使用 Num=。

## 数字

在任何编程语言中，被处理最多的数据类型，就是数字，而 Fundot 当中首先支持的数据类型也是数字。在 Fundot 中，由于极简主义设计理念，不对数字类型进行具体区分。但是目前 Fundot 官方所提供的解释器使用 C++ 中的 double 为 Fundot 的浮点数，使用 C++ 中的 long long 为 Fundot 的整数，任何处于以上范围的数字，都可以正常使用。下面为大家介绍一下 Fundot 当中与数字相关的内置函数：

* Num=
* Num>
* Num<
* Num>=
* Num<=
* Num+
* Num-
* Num*
* Num/
* Num%

由于以上函数的含义和作用十分简单，可以直接顾名思义，这里不进行详细介绍，而是直接给出示例代码：

```Fundot
>>> Def x 1.
>>> Def y 2.
>>> Num= x y.
false
>>> Num> x y.
false
>>> Num< x y.
true
>>> Num>= x y.
false
>>> Num<= x y.
true
>>> Num+ x y.
3
>>> Num- x y.
-1
>>> Num* x y.
2
>>> Num/ 1 2.
0.500000
>>> Num% 1 2.
1
```

## Atom 函数

Atom 函数在 Fundot 当中作用很简单，但是很多时候会作为重要的断言：Atom 函数会对参数进行判断，如果参数为一个原子，就返回 true，否则会返回 false，示例如下：

```Fundot
>>> Atom 1.
true
>>> Atom x.
true
>>> Atom 'Num+ 1 1..
false
>>> Atom [ 1 2 3 ].
false
>>> Atom [ ].
true
```

其中第三个表达式中 Num+ 的前方使用了前缀单引号，作用是使整个表达式被 Quote 函数包含，所以 Atom 的返回值是 false，如果不加单引号，那么返回结果会是 true，因为在进行判断之前，`Num+ 1 1.`就会被执行，从而变成原子 2。而第四个和第五个表达式所涉及到的内容，将会在 Vect 函数的内容当中进行详细讲解。

## 向量

向量可以说是 Fundot 当中最原生的数据结构，因为每一个表达式都可以被看作是一个向量，其中首字母大写的单词标注开始，结尾有点的单词标注结束。这也就是为什么，之前说一个空的向量也是一个原子。

### Vect 函数

而 Vect 函数只不过是显性地告诉我们，被 Vect 函数所包含的内容，是一个向量，并且标注开始和结束而已。但它的作用却可以在处理原子序列的时候得到体现：

```Fundot
a b c d e
```

对于这样一串原子，我们没有办法知道他们的包含关系，这是因为原子在 Fundot 当中并不具备像表达式那样标注开始和结束的能力，此时 Vect 函数就可以发挥作用：

```Fundot
>>> Vect a b c d e.
Vect a b c d e .
>>> Vect Vect a b c. Vect d e..
Vect Vect a b c . Vect d e . .
```

我们可以看到，这样我们就可以清晰地表达出这样一串原子的逻辑关系，但是这样的表达方式，对于我们人类来说，并没有起到易读的效果，反而与我们的设计哲学相悖，所以我们引入了 Vect 符号。

### Vect 符号

Vect 符号的作用与 Vect 函数完全相同，可以理解成是一种更加易读的替代方案，使用方法如下：

```Fundot
>>> [ a b c d e ]
Vect a b c d e .
>>> [ [ a b c ] [ d e ] ]
Vect Vect a b c . Vect d e . .
```

这样，我们对 Vect 函数的使用，就变得更加直观和高效。

### 向量操作函数

* At
* Push
* Pop

#### At 函数

At 函数的意思非常的直观，就是返回向量当中指定位置的元素，示例如下：

```Fundot
>>> Def v [ 1 2 3 ].
>>> At v 1.
2
>>> Def v [ [ 1 2 ] 3 4 ].
>>> At v 0.
Vect 1 2 .
```

由于向量中的元素可以是一个原子，也可以是另外一个向量，所以说，如果指定位置的元素是一个向量，则返回这个向量。

#### Push 函数

Push 函数的作用是返回一个具有第一个参数向量内容并在末尾添加了第二个参数的向量，示例如下：

```Fundot
>>> Push [ 1 2 3 ] 4.
Vect 1 2 3 4 .
>>> Push [ [ 1 2 ] [ 3 4 ] ] [ 5 6 ].
Vect Vect 1 2 . Vect 3 4 . Vect 5 6 . . 
```

由于向量中的元素可以是一个原子，也可以是另外一个向量，所以说，如果第二个参数元素是一个向量，则在末尾添加的也是这个向量。

#### Pop 函数

Pop 函数的作用是返回一个具有第一个参数向量内容但是不包括末尾内容的向量，示例如下：

```Fundot
>>> Pop [ 1 2 3 ].
Vect 1 2 .
>>> Pop [ [ 1 2 ] [ 3 4 ] ].
Vect Vect 1 2 . . 
```

由于向量中的元素可以是一个原子，也可以是另外一个向量，所以说，如果末尾元素是一个向量，则除外整个末尾向量。

### Lisp 公理函数

由于受到了 Lisp 语言的启发，Fundot 也提供了 Lisp 当中的公理函数：

* CAR / First
* CDR / Rest
* Cons

#### CAR / First 函数

CAR 和 First 在 Fundot 当中互为替代，表示相同的函数，作用是返回参数向量当中的第一个元素，示例如下：

```Fundot
>>> CAR [ 1 2 3 ].
1
>>> First [ 1 2 3 ].
1
>>> First [ [ 1 2 3 ] 4 5 ].
Vect 1 2 3 .
```

由于向量中的元素可以是一个原子，也可以是另外一个向量，所以说，如果第一个元素是一个向量，则返回这个向量。

#### CDR / Rest 函数

CDR 和 Rest 在 Fundot 当中互为替代，表示相同的函数，作用是返回参数向量当中除第一个元素以外的其他元素所组成的向量，示例如下：

```Fundot
>>> CDR [ 1 2 3 ].
Vect 2 3 .
>>> Rest [ 1 2 3 ].
Vect 2 3 .
>>> Rest [ [ 1 2 3 ] 4 5 ].
Vect 4 5 .
```

结合 First 函数和 Rest 函数，我们就可以访问一个向量当中所有的元素，比如：

```Fundot
>>> First Rest [ 1 2 3 ]..
2
>>> First Rest Rest [ 1 2 3 ]...
3
>>> First First [ [ 1 2 3 ] 4 5 ]..
1
>>> First Rest First [ [ 1 2 3 ] 4 5 ]...
2
```

在以上代码中，我们就分别访问了 [1 2 3] 当中的第二个和第三个元素，以及 [[1 2 3] 4 5] 当中的第一个元素中的第一个和第二个元素。

#### Cons 函数

Cons 函数的作用是将第一个参数插入到第二个参数向量当中的第一位，示例如下：

```Fundot
>>> Cons 1 [ 2 3 ].
Vect 1 2 3 .
>>> Cons [ 1 2 ] [ 3 4 ].
Vect Vect 1 2 . 3 4 . 
```

不管第一个参数是原子还是向量，我们都可以进行插入。

到目前为止，Lisp 语言当中的七大公理函数已经全部讲解完毕，分别如下：

* Quote
* Atom
* Equal
* Cond
* CAR
* CDR
* Cons

它们之所以被称为七大公理函数，是因为任何一个其它函数，都可以由以上七个函数和相关运算结合而成。若对此有兴趣，可以对 Lisp 七大公理方面的知识进行相关学习。但是事实上，因为 Lisp 语言当中，基础的数据类型为列表（list），而 Fundot 的基础数据类型却是向量（vector），如果我们强行使用以上函数反而会适得其反，请读者尽量使用前一个章节所提供的函数。需要认识到的是，使用前一个章节的函数，可以对本章节中的三个函数进行构造，所以在 Fundot 当中，最基础的七个公理函数为：

* Quote
* Atom
* Equal
* Cond
* At
* Push
* Pop

## Block 函数

以上我们所讲解的函数，都是对单一的表达式进行执行，但是有些时候，我们需要一个代码块，逐句执行表达式，这个时候，我们就可以使用 Block 函数。Block 函数本身的执行也是以表达式的形式，只不过会返回最后一个值，示例如下：

```Fundot
>>> Block Def x 1. Num+ x x..
2
```

在以上代码当中，Def 函数先被执行，所以 Num+ 当中的 x 就会被替换成 1，而 Block 函数的作用就是返回其中最后一个值，也就是 2。

### Block 符号

考虑到 Block 函数在程序开发当中可能具有的重要性，以及与接下来要介绍的 While 函数的强相关性，Fundot 语言也给 Block 函数提供了替代符号，以上程序可以被重写为：

```Fundot
>>> { Def x 1. Num+ x x. }
2
```

